/*
	UIZE JAVASCRIPT FRAMEWORK 2012-01-10

	http://www.uize.com/reference/Uize.Test.Uize.Util.PropertyAdapter.html
	Available under MIT License or GNU General Public License -- http://www.uize.com/license.html
*/
Uize.module({name:'Uize.Test.Uize.Util.PropertyAdapter',required:'Uize.Class',builder:function(){var _a=Uize.Class.subclass();function _b(_c){var _d=new _a({energy:'solar'}),_e=new _a({energy:'wind'});return{_d:_d,_e:_e,_f:Uize.Util.PropertyAdapter(Uize.copyInto({propertyA:{instance:_d,property:'energy'},propertyB:{instance:_e,property:'energy'}},_c))};}function _g(){var _d=new _a({normal:2}),_e=new _a({scaled:4});return{_d:_d,_e:_e,_f:Uize.Util.PropertyAdapter({propertyA:{instance:_d,property:'normal'},propertyB:{instance:_e,property:'scaled'},valueAdapter:{aToB:function(_h){return _h*2},bToA:function(_h){return _h/2}}})};}function _i(_j){var _k='property'+_j;function _l(_m,_h,_n){return{title:_m,test:function(){var _f=Uize.Util.PropertyAdapter();_f.set(_k,_h);return this.expect(_n,_f.get(_k));}};}var _o=Uize.Class();return{title:'Test that the conformer for '+_k+' works correctly',test:[_l(
'Test that specifying simply an instance is resolved to an object where the instance property for the object is set to the specified instance, and the property property is set to "value"',_o,{instance:_o,property:'value'}),{title:'Test that an array value is conformed correctly, where the first element specifies the instance and the second element specifies the property',test:[_l('Test that specifying an array is resolved to an object where the instance is the first element from the array, and the property is the second element from the array',[_o,'foo'],{instance:_o,property:'foo'}),_l('Test the specifying the value null for the second element results in the property being defaulted to the "value" property',[_o,null],{instance:_o,property:'value'}),_l('Test the specifying the value undefined for the second element results in the property being defaulted to the "value" property',[_o,undefined],{instance:_o,property:'value'}),_l(
'Test that not specifying a second element results in the property being defaulted to the "value" property',[_o],{instance:_o,property:'value'})]},{title:'Test that an object value is conformed correctly, where the property property is defaulted to "value" if it is null, undefined, or omitted',test:[_l('Test the specifying the value null for the property results in the property being defaulted to "value"',{instance:_o,property:null},{instance:_o,property:'value'}),_l('Test the specifying the value undefined for the property results in the property being defaulted to "value"',{instance:_o,property:undefined},{instance:_o,property:'value'}),_l('Test that not specifying the property results in it being defaulted to "value"',{instance:_o},{instance:_o,property:'value'})]},{title:'Test that null or undefined is conformed correctly (ie. left as is)',test:[_l('Test the specifying the value null for the value adapter results in it remaining null',null,null),_l(
'Test the specifying the value undefined for the value adapter results in it remaining null',undefined,undefined)]}]};}return Uize.Test.declare({title:'Test for Uize.Util.PropertyAdapter Module',test:[Uize.Test.requiredModulesTest('Uize.Util.PropertyAdapter'),{title:'Test that an instance of the class can be successfully created',test:function(){return this.expectInstanceOf(Uize.Util.PropertyAdapter,Uize.Util.PropertyAdapter());}},{title:'Test that connecting a property adapter between two properties of different objects immediately synchronizes property B to property A',test:function(){var _p=_b();return this.expect('solar',_p._e.get('energy'));}},{title:'Test basic synchronization (without a value adapter) in both directions',test:[{title:'Test that a property adapter correctly synchronizes from property A to property B',test:function(){var _p=_b();_p._d.set({energy:'geothermal'});return this.expect('geothermal',_p._e.get('energy'));}},{
title:'Test that a property adapter correctly synchronizes from property B to property A',test:function(){var _p=_b();_p._e.set({energy:'geothermal'});return this.expect('geothermal',_p._d.get('energy'));}}]},{title:'Test that synchronization with a value adapter works in both directions',test:[{title:'Test that a value adapter is applied correctly when synchronizing from propertyA to propertyB',test:function(){var _p=_g();_p._d.set({normal:2.5});return this.expect(5,_p._e.get('scaled'));}},{title:'Test that a value adapter is applied correctly when synchronizing from propertyB to propertyA',test:function(){var _p=_g();_p._e.set({scaled:5});return this.expect(2.5,_p._d.get('normal'));}}]},{title:'Test that changing the value adapter after properties have already been connected is handled correctly',test:[{
title:'Test that changing a value adapter mid-stream results in propertyB being immediately re-synchronized to propertyA using the new value adapter, with correct synchronization in both directions thereafter',test:function(){var _p=_g();_p._f.set({valueAdapter:{aToB:function(_h){return _h*3},bToA:function(_h){return _h/3}}});var _q=_p._e.get('scaled');_p._d.set({normal:5});var _r=_p._e.get('scaled');_p._e.set({scaled:30});var _s=_p._d.get('normal');return(this.expect(6,_q)&&this.expect(15,_r)&&this.expect(10,_s));}},{title:'Test that nulling out a value adapter mid-stream results in propertyB being immediately re-synchronized to propertyA without any value adapter translation, with correct synchronization in both directions thereafter',test:function(){var _p=_g();_p._f.set({valueAdapter:null});var _q=_p._e.get('scaled');_p._d.set({normal:5});var _r=_p._e.get('scaled');_p._e.set({scaled:30});var _s=_p._d.get('normal');return(this.expect(2,_q)&&this.expect(5,_r)&&this.expect(30,_s));}}]},{
title:'Test that the connected set-get property is observed correctly',test:[{title:'Test that connecting a property adapter between two properties of different objects with the adapter not initially connected results in property B *not* being immediately synchronized to property A',test:function(){var _p=_b({connected:false});return this.expect('wind',_p._e.get('energy'));}},{title:'Test that disconnecting a property adapter by setting its connected set-get property to false results in properties no longer being synchronized',test:function(){var _p=_b();_p._f.set({connected:false});_p._d.set({energy:'geothermal'});var _r=_p._e.get('energy');_p._e.set({energy:'tidal'});var _s=_p._d.get('energy');return(this.expect('solar',_r)&&this.expect('geothermal',_s));}},{title:'Test that disconnecting and then reconnecting a property adapter results in properties once again being synchronized correctly',test:function(){var _p=_b();_p._f.set({connected:false});_p._f.set({connected:true});_p._d.set({energy:'geothermal'});
var _r=_p._e.get('energy');_p._e.set({energy:'tidal'});var _s=_p._d.get('energy');return(this.expect('geothermal',_r)&&this.expect('tidal',_s));}}]},{title:'Test that the conformer for the propertyA and propertyB set-get properties works correctly',test:[_i('A'),_i('B')]},{title:'Test that changing either propertyA or propertyB mid-stream is handled correctly',test:[{title:'Test that when changing propertyA, propertyB is immediately re-synchronized to the new property for propertyA',test:function(){var _p=_b();_p._f.set({propertyA:{instance:new _a({energy:'biofuel'}),property:'energy'}});return this.expect('biofuel',_p._e.get('energy'));}},{title:'Test that when changing propertyB, propertyB is immediately synchronized to the property for propertyA',test:function(){var _p=_b(),_t=new _a({energy:'geothermal'});_p._f.set({propertyB:{instance:_t,property:'energy'}});return this.expect('solar',_t.get('energy'));}},{
title:'Test that when changing propertyA, the old property for propertyA is no longer synchronized when the property for propertyB is modified',test:function(){var _p=_b();_p._f.set({propertyA:{instance:new _a({energy:'geothermal'}),property:'energy'}});_p._e.set({energy:'tidal'});return this.expect('solar',_p._d.get('energy'));}},{title:'Test that after changing propertyA, modifying the value of the old property for propertyA no longer has an affect on the property for propertyB',test:function(){var _p=_b();_p._f.set({propertyA:{instance:new _a({energy:'geothermal'}),property:'energy'}});_p._d.set({energy:'tidal'});return this.expect('geothermal',_p._e.get('energy'));}},{title:'Test that when changing propertyB, the old property for propertyB is no longer synchronized when the property for propertyA is modified',test:function(){var _p=_b(),_t=new _a({energy:'geothermal'});_p._f.set({propertyB:{instance:_t,property:'energy'}});_p._d.set({energy:'tidal'});return this.expect('solar',_p._e.get('energy'));}},{
title:'Test that after changing propertyB, modifying the value of the old property for propertyB no longer has an affect on the property for propertyA',test:function(){var _p=_b();_p._f.set({propertyB:{instance:new _a({energy:'geothermal'}),property:'energy'}});_p._e.set({energy:'tidal'});return this.expect('solar',_p._d.get('energy'));}}]},{title:'Test that nulling out either or both of propertyA and propertyB, after properties have already been connected, is handled correctly',test:[{title:'Test that changing propertyA to null after a property adapter has already been connected is handled correctly',test:function(){var _p=_b();_p._f.set({propertyA:null});var _u=_p._e.get('energy');_p._d.set({energy:'geothermal'});var _v=_p._e.get('energy');_p._e.set({energy:'tidal'});var _w=_p._d.get('energy');return(this.expect('solar',_u)&&this.expect('solar',_v)&&this.expect('geothermal',_w));}},{title:'Test that changing propertyB to null after a property adapter has already been connected is handled correctly',
test:function(){var _p=_b();_p._f.set({propertyB:null});var _x=_p._e.get('energy');_p._e.set({energy:'geothermal'});var _y=_p._d.get('energy');_p._d.set({energy:'tidal'});var _z=_p._e.get('energy');return(this.expect('solar',_x)&&this.expect('solar',_y)&&this.expect('geothermal',_z));}},{title:'Test that changing propertyA and propertyB to null after a property adapter has already been connected is handled correctly',test:function(){var _p=_b();_p._f.set({propertyA:null,propertyB:null});var _A=_p._d.get('energy'),_B=_p._d.get('energy');_p._d.set({energy:'geothermal'});var _C=_p._e.get('energy');_p._e.set({energy:'tidal'});var _D=_p._d.get('energy');return(this.expect('solar',_A)&&this.expect('solar',_B)&&this.expect('solar',_C)&&this.expect('geothermal',_D));}}]},{title:'Test that the infinite loop prevention mechanism works correctly',test:[{title:'Test that the infinite loop prevention mechanism does not prevent two properties of the same instance from being connected successfully by an adapter',
test:function(){var _E=new _a({prop1:'foo',prop2:'bar'}),_f=Uize.Util.PropertyAdapter({propertyA:{instance:_E,property:'prop1'},propertyB:{instance:_E,property:'prop2'}}),_F=_E.get('prop2');_E.set({prop1:'doo'});var _r=_E.get('prop2');_E.set({prop2:'goo'});var _s=_E.get('prop1');return(this.expect('foo',_F)&&this.expect('doo',_r)&&this.expect('goo',_s));}},{title:'Test that the infinite loop prevention mechanism does not prevent three properties of the same instance from being connected successfully by two adapters',test:function(){var _E=new _a({prop1:'foo',prop2:'bar',prop3:'ha'}),_G=Uize.Util.PropertyAdapter({propertyA:{instance:_E,property:'prop1'},propertyB:{instance:_E,property:'prop2'}}),_H=Uize.Util.PropertyAdapter({propertyA:{instance:_E,property:'prop2'},propertyB:{instance:_E,property:'prop3'}}),_I=_E.get('prop2'),_J=_E.get('prop3');_E.set({prop1:'doo'});var _K=_E.get('prop2'),_L=_E.get('prop3');_E.set({prop2:'hoo'});var _M=_E.get('prop1'),_N=_E.get('prop3');_E.set({prop3:'hoo'});var
 _O=_E.get('prop1'),_P=_E.get('prop2');return(this.expect('foo',_I)&&this.expect('foo',_J)&&this.expect('doo',_K)&&this.expect('doo',_L)&&this.expect('hoo',_M)&&this.expect('hoo',_N)&&this.expect('hoo',_O)&&this.expect('hoo',_P));}},{title:'Test that an infinite loop is prevented when two properties combined in a property adapter are guaranteed to never be able to ever settle their values, because of a divergent value adapter',test:function(){var _a=Uize.Class.subclass();_a.registerProperties({_Q:'property1',_R:'property2'});var _E=new _a,_f=Uize.Util.PropertyAdapter({propertyA:{instance:_E,property:'property1'},propertyB:{instance:_E,property:'property2'},valueAdapter:{aToB:function(_h){return _h*2},bToA:function(_h){return _h*2}}});_E.set({property1:1});return true;}},{title:'Test that an infinite loop is prevented when two properties combined in a property adapter are guaranteed to never be able to ever settle their values, based upon the definition of those properties',test:function(){
var _S=Uize.Class.subclass();_S.registerProperties({_Q:{name:'property1',conformer:function(_h){return _h+1},value:1},_R:{name:'property2',conformer:function(_h){return _h+1},value:1}});var _E=new _S,_f=Uize.Util.PropertyAdapter({propertyA:{instance:_E,property:'property1'},propertyB:{instance:_E,property:'property2'}});_E.set({property1:10});return true;}}]}]});}});